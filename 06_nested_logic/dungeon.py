"""
Dungeon Explorer - Nested Conditions and Loops Exercise
Generated by Copilot
"""


def can_open_chest(has_key: bool, chest_locked: bool, strength: int) -> str:
    """
    Determine if a chest can be opened based on multiple conditions.
    
    Args:
        has_key: Whether the player has a key
        chest_locked: Whether the chest is locked
        strength: The player's strength value
    
    Returns:
        "Chest opened!" or "Chest remains closed"
    """
    # TODO: Check if chest can be opened (not locked OR has key OR strength > 10)
    pass


def explore_room(room_type: str, has_torch: bool) -> str:
    """
    Explore a room and return what's found based on room type and equipment.
    
    Args:
        room_type: The type of room
        has_torch: Whether the player has a torch
    
    Returns:
        A message describing what was found
    """
    # TODO: Use nested conditions to check room type and torch status
    pass


def count_monsters_in_dungeon(dungeon_map: list[list[str]]) -> int:
    """
    Count the number of monsters in a 2D dungeon map.
    
    Args:
        dungeon_map: A 2D list representing the dungeon
    
    Returns:
        The count of monsters
    """
    # TODO: Use nested loops to iterate through the grid and count monsters
    pass


def find_treasure_position(dungeon_map: list[list[str]]) -> tuple[int, int] | None:
    """
    Find the position of treasure in the dungeon map.
    
    Args:
        dungeon_map: A 2D list representing the dungeon
    
    Returns:
        A tuple (row, col) of the treasure position, or None if not found
    """
    # TODO: Use nested loops to search for treasure, return position as tuple
    pass


def calculate_damage(attacks: list[dict]) -> int:
    """
    Calculate total damage from a list of attacks.
    
    Args:
        attacks: A list of dictionaries with "type" and "power" keys
    
    Returns:
        Total damage calculated
    """
    # TODO: Loop through attacks and calculate damage based on type
    pass


def safe_path_exists(grid: list[list[str]], start_row: int, start_col: int) -> bool:
    """
    Check if a safe path exists from start to bottom-right corner.
    
    Args:
        grid: A 2D list where "safe" cells are passable
        start_row: Starting row index
        start_col: Starting column index
    
    Returns:
        True if safe path exists, False otherwise
    """
    # TODO: Check if starting position is safe, then check if can reach bottom-right
    # by only moving right or down through safe cells
    pass


def generate_pattern(rows: int, cols: int, fill_char: str) -> list[list[str]]:
    """
    Generate a 2D pattern filled with a character.
    
    Args:
        rows: Number of rows
        cols: Number of columns
        fill_char: Character to fill each cell
    
    Returns:
        A 2D list filled with fill_char
    """
    # TODO: Use nested loops to create a 2D list
    pass


def get_room_types(dungeon_map: list[list[str]]) -> dict[str, int]:
    """
    Count occurrences of each room type in the dungeon.
    
    Args:
        dungeon_map: A 2D list representing the dungeon
    
    Returns:
        A dictionary mapping room types to their counts
    """
    # TODO: Use nested loops to count each room type
    pass
