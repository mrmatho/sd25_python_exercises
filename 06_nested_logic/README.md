# Exercise 06: Nested Conditions and Loops

<!-- Generated by Copilot -->

## ðŸŽ¯ Theme: Dungeon Explorer

## ðŸ“ Objective

Practice writing nested `if` statements and nested loops to solve more complex logic problems.

## ðŸ“‹ Instructions

You are building a text-based dungeon exploration game. Complete the functions in `dungeon.py` using nested conditions and loops.

Implement these functions:

1. `can_open_chest(has_key: bool, chest_locked: bool, strength: int) -> str`
   - Return `"Chest opened!"` if:
     - The chest is not locked, OR
     - The player has a key, OR
     - The player's strength is greater than 10
   - Otherwise return `"Chest remains closed"`

2. `explore_room(room_type: str, has_torch: bool) -> str`
   - Return different messages based on room type and whether the player has a torch:
     - `"dark_cave"` without torch: `"Too dark to explore"`
     - `"dark_cave"` with torch: `"You found a treasure chest!"`
     - `"library"`: `"You found an ancient book"` (torch doesn't matter)
     - `"armory"` without torch: `"Too dark to explore"`
     - `"armory"` with torch: `"You found a legendary sword!"`
     - Any other room: `"Nothing interesting here"`

3. `count_monsters_in_dungeon(dungeon_map: list[list[str]]) -> int`
   - The dungeon is represented as a 2D grid (list of lists).
   - Count how many cells contain `"monster"` (case-insensitive).
   - Return the total count.

4. `find_treasure_position(dungeon_map: list[list[str]]) -> tuple[int, int] | None`
   - Search the 2D dungeon map for `"treasure"` (case-insensitive).
   - Return a tuple `(row, col)` of its position (0-indexed).
   - If not found, return `None`.

5. `calculate_damage(attacks: list[dict]) -> int`
   - Each attack is a dictionary with keys `"type"` and `"power"`.
   - Calculate total damage:
     - `"critical"` attacks: multiply power by 2
     - `"normal"` attacks: use power as-is
     - `"weak"` attacks: divide power by 2 (use integer division)
   - Return the total damage.

6. `safe_path_exists(grid: list[list[str]], start_row: int, start_col: int) -> bool`
   - Check if there's a safe path from the starting position going only right and down.
   - A cell is safe if it contains `"safe"`.
   - A cell is dangerous if it contains anything else.
   - The path must reach the bottom-right corner of the grid.
   - Return `True` if a safe path exists, `False` otherwise.

7. `generate_pattern(rows: int, cols: int, fill_char: str) -> list[list[str]]`
   - Create a 2D grid (list of lists) with the specified dimensions.
   - Fill every cell with `fill_char`.
   - Return the 2D grid.

8. `get_room_types(dungeon_map: list[list[str]]) -> dict[str, int]`
   - Count occurrences of each unique room type in the dungeon map.
   - Return a dictionary mapping room types to their counts.
   - Example: `{"empty": 5, "monster": 3, "treasure": 1}`

## ðŸ’¡ Example

```python
can_open_chest(True, True, 5)  # "Chest opened!" (has key)
can_open_chest(False, True, 15)  # "Chest opened!" (strength > 10)
explore_room("dark_cave", True)  # "You found a treasure chest!"
count_monsters_in_dungeon([["empty", "monster"], ["monster", "treasure"]])  # 2
find_treasure_position([["empty", "monster"], ["treasure", "empty"]])  # (1, 0)
calculate_damage([{"type": "critical", "power": 10}, {"type": "normal", "power": 5}])  # 25
safe_path_exists([["safe", "safe"], ["safe", "safe"]], 0, 0)  # True
generate_pattern(2, 3, "X")  # [["X", "X", "X"], ["X", "X", "X"]]
get_room_types([["empty", "monster"], ["empty", "treasure"]])  # {"empty": 2, "monster": 1, "treasure": 1}
```

## ðŸ“š Required Knowledge: Nested Conditions

Nested `if` statements allow you to check multiple conditions where one condition depends on another.

```python
age = 25
has_license = True

if age >= 18:
    if has_license:
        status = "Can drive"
    else:
        status = "Need license"
else:
    status = "Too young"
```

You can also use `and`/`or` operators to combine conditions without nesting:

```python
if age >= 18 and has_license:
    status = "Can drive"
```

## ðŸ“š Required Knowledge: Nested Loops

Nested loops let you iterate through multi-dimensional data structures like 2D grids.

```python
# 2D grid example
grid = [
    ["A", "B", "C"],
    ["D", "E", "F"],
    ["G", "H", "I"]
]

# Nested loop to access every cell
for row in grid:
    for cell in row:
        print(cell)  # Prints A, B, C, D, E, F, G, H, I

# With indices
for i in range(len(grid)):
    for j in range(len(grid[i])):
        print(f"Row {i}, Col {j}: {grid[i][j]}")
```

## ðŸ“š Required Knowledge: 2D Lists (Grids)

A 2D list is a list of lists, often used to represent grids, maps, or tables.

```python
# Creating a 2D list
dungeon = [
    ["empty", "monster", "empty"],
    ["treasure", "empty", "trap"],
    ["empty", "exit", "empty"]
]

# Accessing elements
top_left = dungeon[0][0]  # "empty"
treasure = dungeon[1][0]  # "treasure"

# Number of rows and columns
num_rows = len(dungeon)  # 3
num_cols = len(dungeon[0])  # 3
```

## ðŸ“š Required Knowledge: Returning None

Functions can return `None` to indicate "no value" or "not found".

```python
def find_item(items, target):
    for i, item in enumerate(items):
        if item == target:
            return i
    return None  # Not found

result = find_item(["apple", "banana"], "orange")
if result is None:
    print("Item not found")
```

## ðŸ“š Required Knowledge: Tuples

Tuples are immutable sequences, often used to return multiple values from a function.

```python
# Creating a tuple
position = (3, 5)  # row 3, column 5

# Unpacking
row, col = position
print(row)  # 3
print(col)  # 5

# Accessing by index
first = position[0]  # 3
second = position[1]  # 5
```

## ðŸ§ª Running the Tests

```pwsh
pytest 06_nested_logic/test_dungeon.py -v
```

## âœ… Success Criteria

- All tests pass for `test_dungeon.py`.
- Your solutions use nested conditions and loops appropriately.
